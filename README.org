#+DATE: 2020-05-10
#+CATEGORY: Emacs
#+STARTUP: showall
#+OPTIONS: toc:t H:3 num:3

[[./README.org][English Doc]] [[./README_ZH.org][中文文档]]

* Table of Contents :TOC_3:
- [[#installation][Installation]]
- [[#usage][Usage]]
  - [[#basic][Basic]]
    - [[#single-s-expression][Single S expression]]
    - [[#paratactic-s-expression][Paratactic S expression]]
    - [[#nested-s-expression][Nested S expression]]
  - [[#objects][Objects]]
    - [[#variable-evaluation][Variable evaluation]]
    - [[#objects-attribute-evaluation][Object's attribute evaluation]]
    - [[#function-evaluation][Function evaluation]]
  - [[#tags][Tags]]
    - [[#variable-assign][Variable assign]]
    - [[#control-flow][Control flow]]
    - [[#interation][Interation]]
    - [[#block][Block]]
  - [[#filters][Filters]]
    - [[#customize-filters][Customize filters]]
    - [[#built-in-filters][Built-in filters]]
  - [[#integration][Integration]]
- [[#tips][Tips]]
  - [[#test-and-preview][Test and Preview]]
  - [[#xml-support][XML support]]
  - [[#blog-package][Blog package]]
- [[#plan][Plan]]
- [[#acknowledgment][Acknowledgment]]

* Installation
  Clone pp-html's github repo to local directory.
  #+BEGIN_SRC shell
  $ git clone https://github.com/Kinneyzhang/pp-html.git <path-to-pp-html>
  #+END_SRC

  #+RESULTS:

  Then, add the following two lines in your emacs configuration.
  #+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "<path-to-pp-html>")
  (require 'pp-html)
  #+END_SRC

* Usage
  
** Basic
   pp-html use elisp's S expression to output html code and use =pp-html= function to evaluate the S expression. Following are some examples for readers' well understanding of the usage of pp-html.

*** Single S expression
    The syntax of single sexp is =(element :attribute value :attribute value ... content)= .
    In sexp, html element is necessary and others are optional. Pairs of attribute and value should be organized in the form of elisp plist. Specially, =id= and =class= attribute can be write in the style of css selector. The char '.' represent 'class' and '@' represent 'id' (without using '#' because it's a special char in elisp syntax). For some attribute without value, such as 'async' 'sync', there are two forms. One is =(:attr nil)= , another is =(:attr)= . The latter one has a condition: it must not be the last attribute.

    Belows are some examples.

    #+BEGIN_SRC emacs-lisp
    (pp-html '(a "content"))
    (pp-html '(a @id .class))
    (pp-html '(a :id "id" :class "class"))
    (pp-html '(a .test :href "url" :target "_blank" "content"))
    (pp-html '(link :async :rel "stylesheet" :href "url" :async nil))
    #+END_SRC

    #+begin_src html
    <a>content</a>
    <a id="id" class="class"></a>
    <a id="id" class="class"></a>
    <a class="test" href="url" target="_blank">content</a>
    <link async rel="stylesheet" href "url" async/>
    #+end_src   
    
*** Paratactic S expression
    Some paratactic sexps should be included by parentheses.
    
    #+BEGIN_SRC emacs-lisp
    (pp-html
     '((div .div1 "div-content")
       (p "paragraph")
       (a :href "url" "a-content")
       (img :src "path")
       (ul .org-ul
           (li "1")
           (li "2")
           (li "3"))))
    #+END_SRC

    #+begin_src html
    <div class="div1">div-content</div>
    <p>paragraph</p>
    <a href="url">a-content</a>
    <img src="path"/>
    <ul class="org-ul">
      <li>1</li>
      <li>2</li>
      <li>3</li>
    </ul>
    #+end_src

*** Nested S expression
    Nested sexp represents for nested html element.

    #+BEGIN_SRC emacs-lisp
    (pp-html
     '(div .container
           (div .row
                (div .col-8
                     (p "paragraph 1"))
                (div .col-4
                     (p "paragraph 2")))))
    #+END_SRC

    #+begin_src html
    <div class="container">
      <div class="row">
        <div class="col-8">
          <p>paragraph 1</p>
        </div>
        <div class="col-4">
          <p>paragraph 2</p>
        </div>
      </div>
    </div>
    #+end_src

** Objects
   Objects tell pp-html where to show content in a page. It includes three types: variable evaluation, object's attribute evaluation and function evaluation. Use function =pp-html-eval= to evaluate object.

*** Variable evaluation
    Variables are denoted by char '$': $var.

    #+BEGIN_SRC emacs-lisp
    (let ((var1 "happy hacking emacs"))
      (pp-html-eval '$var1))
    #+END_SRC

    #+begin_src html
    happy hacking emacs
    #+end_src

    Variables can be used in any part of sexp.

    #+BEGIN_SRC emacs-lisp
    (let ((url "https://geekinney.com/")
          (name "Geekblog"))
      (pp-html '(a :href $url $name)))
    #+END_SRC

    #+begin_src html
    <a href="https://geekinney.com/">Geekblog</a>
    #+end_src

*** Object's attribute evaluation
    For objects in style of elisp plist, use dot to get value.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (let ((site '(:name "Geekblog" :domain "geekinney.com" :author "Geekinney")))
      (pp-html '(div .site-info
                     (p $site.name)
                     (p $site.domain)
                     (p $site.author))))
    #+END_SRC

    #+begin_src html
    <div class="site-info">
      <p>Geekblog</p>
      <p>geekinney.com</p>
      <p>Geekinney</p>
    </div>
    #+end_src

*** Function evaluation
    The form of function in pp-html sexp is =($ <function> <args...>)= . Arguments can be write in style of variable.

    #+BEGIN_SRC emacs-lisp
    (let ((var1 "happy")
          (var2 " hacking"))
      (pp-html-eval '($ concat $var1 $var2 " emacs")))
    #+END_SRC

    #+begin_src html
    happy hacking emacs
    #+end_src

    The arguments can also be functions. There are two equal forms.
    
    #+BEGIN_SRC emacs-lisp
    (let ((var1 "now")
          (var2 " is ")
          (now '(current-time)))
      (pp-html-eval '($ concat ($ upcase $var1) $var2 ($ format-time-string "%Y-%m-%d" $now)))
      (pp-html-eval '($ concat (upcase $var1) $var2 (format-time-string "%Y-%m-%d" $now))))
    #+END_SRC

    #+begin_src html
    NOW is 2020-05-10
    NOW is 2020-05-10
    #+end_src    

    The same as 'variable evaluation', functions can be used in any part of sexp. Now, we can use abundant emacs-lisp functions in pp-html. Bravo!

** Tags
   Tags create the logic and control flow for templates. They are denoted by colon and should be placed in the first position of sexp: (:tag ...). Tags can be categorized into five types: 

   * Variable assign
   * Control flow
   * Iteration
   * Block

*** Variable assign

    *assign*

    =:assign= create new pp-html variables, the equivalent in elisp is 'let' or 'setq'.
    
    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html
     '((:assign str1 "happy"
                str2 "hacking"
                str3 "emacs")
       (p ($ concat $str1 " " $str2 " " $str3))))
    #+END_SRC

    #+begin_src html
    <p>happy hacking emacs</p>
    #+end_src

*** Control flow
    Control flow tags can change the information pp-html shows using programming logic.
    
    *if*

    Executes a block of code only if a certain condition is true.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html
     '((:assign bool nil)
       (:if $bool (p "true")
	    (p "false"))))
    #+END_SRC

    #+begin_src html
    <p>false</p>
    #+end_src

    *unless*

    The opposite of if – executes a block of code only if a certain condition is not met.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html
     '((:assign bool nil)
       (:unless $bool (p "true")
	    (p "false"))))
    #+END_SRC

    #+begin_src html
    <p>true</p>
    #+end_src

    *cond*

    Try each clause until one succeeds. Each clause looks like (CONDITION BODY...). Return the value of last one in body.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html
     '((:assign case "case3")
       (:cond
        ($ string= $case "case1") (p "case1 branch")
        ($ string= $case "case2") (p "case2 branch")
        ($ string= $case "case3") (p "case3 branch")
        t (p "default branch"))))
    #+END_SRC

    #+begin_src html
    <p>case3 branch</p>
    #+end_src    

*** Interation
    Iteration tags run blocks of code repeatedly.

    *for*

    Repeatedly executes a block of code.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html
     '((:assign editors ("vim" "emacs" "vscode"))
       (ul
        (:for editor in $editors
              (li :id $editor $editor)))))
    #+END_SRC

    #+begin_src html
    <ul>
      <li id="vim">vim</li>
      <li id="emacs">emacs</li>
      <li id="vscode">vscode</li>
    </ul>
    #+end_src

    ... *cycle* and *table* is one the way!

*** Block
    
    *include*

    Include other blocks in one block.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (setq block1
          '(p "block1 content"
              (a :href "url" "content")))

    (setq block2
          '(div .block2
                (p "block2 content")
                (:include $block1)))

    (pp-html block2)
    #+END_SRC

    #+begin_src html
    <div class="block2">
      <p>block2 content</p>
      <p>
        block1 content
        <a href="url">content</a>
      </p>
    </div>
    #+end_src

    *extend* and *block*

    Extend a block, replace the block in =:block= tag if has new block, otherwise extend the default one.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (setq base-block '(p .base
                         (:block block-name (span "base content")))
          extend-block1 '(:extend $base-block
                                  (:block block-name))
          extend-block2 '(:extend $base-block
                                  (:block block-name
                                          (span "extended content"))))
    (pp-html
     '((div "extend the default"
            (:include $extend-block1))
       (div "extend with new"
            (:include $extend-block2))))
    #+END_SRC

    #+begin_src html
    <div>
      extend the default
      <p class="base">
        <span>base content</span>
      </p>
    </div>
    <div>
      extend with new
      <p class="base">
        <span>extended content</span>
      </p>
    </div>
    #+end_src

** Filters
   Filters change the output of a pp-html object. The form of filter is =(/ <value> <:filter args> ...)= . Some filters have argument and others have none, it all depends.

*** Customize filters
    pp-html support to customize filters by yourself using =pp-html-define-filter= function. The function has two arguments: the name of a filter and a filter function.

    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html-define-filter :add 'pp-html-filter-add)
    (defun pp-html-filter-add (value arg)
      "Add a value to a number"
      (let ((arg (if (stringp arg)
		     (string-to-number arg)
		   arg)))
	(+ value arg)))
    #+END_SRC

    The code above defined a filter named ':add', the function is 'pp-html-filter-add'. The name of filter function is up to you.

*** Built-in filters

    *abs*: returns the absolute value of a number
    #+BEGIN_SRC emacs-lisp :wrap src html
    (pp-html-eval '(/ -5 :abs)) ;; => 5
    #+END_SRC

    *append*: appends a list to another one
    #+BEGIN_SRC emacs-lisp
    (let ((list1 '(1 2 3))
          (list2 '(5 6 7)))
      (pp-html-eval '(/ $list1 :append $list2))) ;; => (1 2 3 5 6 7)
    #+END_SRC

    *capitalize*: makes the first character of a string capitalized
    #+BEGIN_SRC emacs-lisp
    (pp-html-eval '(/ "happy hacking emacs!" :capitalize)) ;; => Happy hacking emacs!
    #+END_SRC

    *compact*: removes any nil values from an array
    #+BEGIN_SRC emacs-lisp
    (let ((lst '(nil 1 2 nil 3 4 nil)))
      (pp-html-eval '(/ $lst :compact))) ;; => (1 2 3 4)
    #+END_SRC

    *concat*: concatenates two strings and returns the concatenated value
    #+BEGIN_SRC emacs-lisp
    (let ((str1 "happy hacking ")
          (str2 "emacs"))
      (pp-html-eval '(/ $str1 :concat $str2))) ;; => happy hacking emacs
    #+END_SRC

    *default*: default will show its value if the left side is nil, false, or empty
    #+BEGIN_SRC emacs-lisp
    (let ((str1 "")
          (str2 "new value")
          (lst1 '(1 2 3))
          (lst2 nil))
      (pp-html-eval '(/ $str1 :default "default value")) ;; => default value
      (pp-html-eval '(/ $str2 :default "default value")) ;; => new value
      (pp-html-eval '(/ $lst1 :default (4 5 6))) ;; => (1 2 3)
      (pp-html-eval '(/ $lst2 :default (4 5 6))) ;; => (4 5 6)
      )
    #+END_SRC

    *escape*: escapes a string by replacing characters with escape sequences
    #+BEGIN_SRC emacs-lisp
    (pp-html-eval '(/ "Have you read 'James & the Giant Peach'?" :escape)) ;; => Have you read &apos;James &amp; the Giant Peach&apos;?
    #+END_SRC

    *join*: combines the items in a list into a single string using the argument as a separator
    #+BEGIN_SRC emacs-lisp
    (let ((lst '("happy" "hacking" "emacs")))
      (pp-html-eval '(/ $lst :join "-"))) ;; => happy-hacking-emacs
    #+END_SRC

    ... *More useful filters is on the way!*
    
** Integration

   [[./example.org][Click to see an integration example.]]

* Tips

** Test and Preview
   Use =pp-html-test= function to preview the formatted HTML generated by S expression. Use =pp-html-parse= function to see the S expression after processing all logic tags. The two functions are useful for test and debug.

** XML support
   pp-html also support print XML. Just set the second argument of =pp-html= to 't' is fine.

** Blog package
   [[https://geekinney.com/][My personal blog site]] is built in the base of =pp-html= because it's handy to build a blog. I will develop a blog site generator emacs package by using pp-html. Please keep watching my [[https://github.com/Kinneyzhang/][Github]]!

* Plan
  * [ ] Support more useful tags.
  * [ ] Support more useful filters.
  * [ ] Write a function named =pp-html-reverse= which can parse HTML string into pp-html's S expression form.

* Acknowledgment
  =pp-html= is the first emacs package developed by myself. During developing it, I have met many challenges. Thanks to emacs hacker in [[https://emacs-china.org][Emacs-China]] for your answering questions.

  BTW, issues and prs are always welcome!

  *If you appreciate my job, please give me a star and fork this repo as you like.*
